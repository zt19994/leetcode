### 双指针技术
#### 场景一
&emsp;&emsp;在前一章中，我们通过迭代数组来解决一些问题。通常，我们只使用从第一个元素开始的一个指针，然后在最后一个元素结束时进行迭代。然而，有时，我们可能需要同时使用两个指针来进行迭代。

##### 例如：
&emsp;&emsp;让我们从一个经典的问题开始：反转数组中的元素。<br>
&emsp;&emsp;其思想是将第一个元素与末端交换，向前移动到下一个元素，并不断地交换，直到它到达中间位置。<br>
&emsp;&emsp;我们可以同时使用两个指针来完成迭代：一个从第一个元素开始，另一个从最后一个元素开始。继续交换元素，直到两个指针相遇。<br>
以下是您的参考代码：
```java
public static void reverse(int[] v, int N) {
    int i = 0;
    int j = N - 1;
    while (i < j) {
        swap(v, i, j);  // this is a self-defined function
        i++;
        j--;
    }
}
```
##### 总结
1. 总而言之，使用双指针技术的一个典型场景是你想要：**从两端到中间迭代数组**。
2. 所以你可以使用双指针技术：**一个指针从一开始就开始，而另一个指针从末端开始**。
3. 值得注意的是，这种技术经常在一个排序的数组中使用。

#### 场景二
&emsp;&emsp;有时，我们可以使用两个指针，用不同的步速来解决问题。

##### 例如：
&emsp;&emsp;让我们从另一个经典问题开始：给定一个数组和一个值，删除该值的所有实例并返回新的长度。<br>
&emsp;&emsp;如果我们没有空间复杂度的限制，会很简单。我们可以用一个新的数组来存储答案，迭代遍历原有的数组，如果元素不等于目标值，添加元素到新数组。<br>
&emsp;&emsp;实际上，使用双指针是等价的，一个指针用于原始数组的迭代，另一个总是指向新数组的最后一个位置。

##### 重新考虑空间限制
&emsp;&emsp;我们可以采用类似的策略。我们仍然使用两个指针：一个仍然用于迭代，而第二个指针总是指向下一个加法的位置。<br>
参考代码：
```java
public int removeElement(int[] nums, int val) {
    int k = 0;
    for (int i = 0; i < nums.length; ++i) {
        if (nums[i] != val) {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}
```
&emsp;&emsp;在上面的例子中，我们使用两个指针，一个快速的i和一个慢速的k。我每次移动一个步骤，而k只在添加一个新的需要值时移动一个步骤。

##### 总结
1. 这是在需要时使用双指针技术的一个非常常见的场景：一个慢跑者和一个快跑者同时。<br>
2. 解决这类问题的关键是确定两个指针的移动策略。<br>
3. 与前面的场景类似，您可能有时需要在使用双指针技术之前对数组进行排序。你可能需要一个贪婪的想法来决定你的运动策略。